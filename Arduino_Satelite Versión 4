// =====================================================
// üõ∞Ô∏è SAT√âLITE v4.8 - DHT + Ultrasonidos + Servo + √ìrbita + AMENAZA ‚Üí TIERRA
// =====================================================

#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>

// ------------------ PINES ------------------
#define DHTPIN 2
#define DHTTYPE DHT11
#define TRIGPIN 6
#define ECHOPIN 7
#define SERVOPIN 9
#define MOTORPIN 12
#define LEDRX 13

// ------------------ OBJETOS ------------------
SoftwareSerial mySerial(10, 11); // RX, TX hacia estaci√≥n (puente)
DHT dht(DHTPIN, DHTTYPE);
Servo servoMotor;

// ------------------ ESTADO GLOBAL ------------------
bool transmitiendo      = false;
bool modoBarrido        = false;
bool arduinoComputeAvg  = false;
bool amenazaActiva      = false;  // Estado para enviar solo cambios

// ------------------ TIEMPOS ------------------
unsigned long intervaloHT    = 5000;
unsigned long nextHT         = 0;
unsigned long intervaloServo = 300;
unsigned long nextServo      = 0;
unsigned long intervaloOrbit = 3000;
unsigned long nextOrbit      = 0;

// ------------------ SERVO ------------------
int angulo     = 90;
int direccion  = 1;
const int PASO = 15;

// ------------------ MEDIA TEMPERATURA ------------------
#define MAX_WINDOW 100
float tempBuffer[MAX_WINDOW];
int   tempCount = 0;
int   windowN   = 10;

// ------------------ √ìRBITA ------------------
const double G                = 6.67430e-11;
const double M                = 5.97219e24;
const double R_EARTH          = 6371000;
const double ALTITUDE         = 400000;
const double TIME_COMPRESSION = 90.0;
double r, real_orbital_period;

// =====================================================
// CHECKSUM y funciones (igual que antes)
unsigned int checksum(String msg) {
  unsigned int sum = 0;
  for (unsigned int i = 0; i < msg.length(); i++) sum += msg[i];
  return sum % 256;
}

void sendMsg(String msg) {
  mySerial.print("CHK:");
  mySerial.print(msg);
  mySerial.print(":");
  mySerial.println(checksum(msg));
}

String limpiarChecksum(String raw) {
  raw.trim();
  if (!raw.startsWith("CHK:")) return raw;
  raw = raw.substring(4);
  int lastColon = raw.lastIndexOf(':');
  if (lastColon > 0) raw = raw.substring(0, lastColon);
  return raw;
}

float medirDistancia() {
  digitalWrite(TRIGPIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIGPIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIGPIN, LOW);
  long duracion = pulseIn(ECHOPIN, HIGH, 25000);
  if (duracion == 0) return -1;
  return duracion * 0.034 / 2.0;
}

void pushTemp(float t) {
  if (tempCount < MAX_WINDOW) tempBuffer[tempCount++] = t;
  else {
    for (int i = 0; i < MAX_WINDOW - 1; i++)
      tempBuffer[i] = tempBuffer[i + 1];
    tempBuffer[MAX_WINDOW - 1] = t;
  }
}

float computeAvg() {
  int n = min(tempCount, windowN);
  if (n == 0) return NAN;
  float s = 0;
  for (int i = tempCount - n; i < tempCount; i++) s += tempBuffer[i];
  return s / n;
}

void enviarOrbita(unsigned long ms) {
  double time  = (ms / 1000.0) * TIME_COMPRESSION;
  double angle = 2 * PI * (time / real_orbital_period);
  double x = r * cos(angle);
  double y = r * sin(angle);
  double z = 0;
  String msg = "Orbit | Time: " + String(time, 2) +
               " s | X: "  + String(x, 2) +
               " m, Y: "   + String(y, 2) +
               " m, Z: "   + String(z, 2);
  sendMsg(msg);
}

// procesarComando() igual que antes...
void procesarComando(String cmd) {
  cmd.trim();
  if (cmd.length() == 0) return;

  if (cmd == "Iniciar") {
    transmitiendo = true;
    modoBarrido  = true;
    nextHT = nextServo = nextOrbit = millis();
    sendMsg("5:INICIADO");
    return;
  }
  if (cmd == "Parar") {
    transmitiendo = false;
    sendMsg("5:PARADO");
    return;
  }

  int sep  = cmd.indexOf(':');
  int code = (sep < 0) ? cmd.toInt() : cmd.substring(0, sep).toInt();
  String val = (sep < 0) ? "" : cmd.substring(sep + 1);

  switch (code) {
    case 1: {
      int s = val.toInt();
      if (s >= 1 && s <= 3600) {
        intervaloHT = s * 1000UL;
        nextHT = millis() + intervaloHT;
        sendMsg("5:PERIODO_DHT=" + String(s));
      }
      break;
    }
    case 2: {
      angulo = constrain(val.toInt(), 0, 180);
      modoBarrido = false;
      servoMotor.write(angulo);
      sendMsg("5:SERVO_MANUAL=" + String(angulo));
      break;
    }
    case 6: {
      modoBarrido = (val == "1");
      sendMsg(modoBarrido ? "5:BARRIDO_ON" : "5:BARRIDO_OFF");
      break;
    }
    case 7: {
      // intervaloUltra = constrain(val.toInt(), 100, 10000);
      sendMsg("5:ULTRA_MS=" + val);
      break;
    }
    case 8: {
      arduinoComputeAvg = (val == "1");
      sendMsg(arduinoComputeAvg ? "5:AVG_ON" : "5:AVG_OFF");
      break;
    }
    case 9: {
      windowN = constrain(val.toInt(), 1, MAX_WINDOW);
      sendMsg("5:WINDOW=" + String(windowN));
      break;
    }
    default:
      sendMsg("5:CMD_DESCONOCIDO");
  }
}

void setup() {
  pinMode(TRIGPIN, OUTPUT);
  pinMode(ECHOPIN, INPUT);
  pinMode(MOTORPIN, OUTPUT);
  pinMode(LEDRX, OUTPUT);

  servoMotor.attach(SERVOPIN);
  servoMotor.write(angulo);

  dht.begin();
  Serial.begin(9600);
  mySerial.begin(9600);

  r = R_EARTH + ALTITUDE;
  real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));

  sendMsg("5:SATELITE_LISTO");
}

void loop() {
  while (mySerial.available()) {
    String raw   = mySerial.readStringUntil('\n');
    String limpio = limpiarChecksum(raw);
    procesarComando(limpio);
  }

  if (!transmitiendo) {
    if (!modoBarrido) servoMotor.write(angulo);
    return;
  }

  // DHT
  if (millis() >= nextHT) {
    nextHT = millis() + intervaloHT;
    float t = dht.readTemperature();
    float h = dht.readHumidity();
    if (!isnan(t) && !isnan(h)) pushTemp(t);
    String msg = "1:" + String(t, 2) + ":" + String(h, 2);
    if (arduinoComputeAvg) msg += ":A:" + String(computeAvg(), 2);
    sendMsg(msg);
  }

  // SERVO + RADAR + AMENAZA ‚Üí ENV√çA A TIERRA
  if (modoBarrido) {
    if (millis() >= nextServo) {
      nextServo = millis() + intervaloServo;
      angulo += PASO * direccion;
      if (angulo >= 180 || angulo <= 0) direccion *= -1;
      servoMotor.write(angulo);

      float d = medirDistancia();
      if (d < 0) {
        sendMsg("6:");
      } else {
        String s = "2:" + String(angulo) + ":" + String(d, 2);
        sendMsg(s);

        // üëâ L√ìGICA AMENAZA: env√≠a mensaje solo al cambiar estado
        if (d > 0 && d < 50.0) {
          if (!amenazaActiva) {
            amenazaActiva = true;
            sendMsg("5:AMENAZA_ON");
          }
        } else if (d >= 50.0) {
          if (amenazaActiva) {
            amenazaActiva = false;
            sendMsg("5:AMENAZA_OFF");
          }
        }
      }
    }
  } else {
    servoMotor.write(angulo);
  }

  // √ìRBITA
  if (millis() >= nextOrbit) {
    nextOrbit = millis() + intervaloOrbit;
    enviarOrbita(millis());
  }
}
